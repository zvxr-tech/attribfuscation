% FIX: incorrect for grid_size = 1
%FIX: look at all length to snsure they are used correctly instead of size

% This program will iteratively generate every unique challenge.
% 
% A challenge is what presented to the user as a grid of GRID_SIZE elements
% each containing one of ATTR_VAL_CNT attribute values of each ATTR_KEY_CNT
% attribute type. Furthermore, for this system (maybe we could explore other
% systems in the future without the following constraint?)the GRID_SIZE 
% will always equal the ATTR_VAL_CNT.

% Ex. 
% 3 grid elements
% 3 attribute keys: Colour, Size, Shape.
% 3 atrribute values (per key): 
%   Colour = {red=1, green=2, blue=3}
%   Size = {small=1, medium=2, large=3}
%   Shape = {circle=1, triangle=2, square=3}
% ,where each attribute key and value can be generalized by enumarating
%  over the positive integers.

% Using the above parameters, we could define a challenge instance:
%   {(1,3,1), (2,2,3), (3,1,2)}
% , which means the three grid elements contain:
% 1) red, large cirlce
% 2) green, medium square
% 3) blue, small triangle
%
% Note: This program is used to perform mathematical simulation
% so it only generates one ordering of the same set of grid elements
% (I.e. grid element ordering does not matter).
% The following challenge instance will not be generated by this program.
% {(2,2,3), (1,3,1), (3,1,2)} and {(1,3,1), (2,2,3), (3,1,2)}
% {(3,1,2), (1,3,1), (2,2,3)} and {(1,3,1), (3,1,2), (2,2,3)}
% {(3,1,2), (2,2,3), (1,3,1)} and {(2,2,3), (3,1,2), (1,3,1)}
% , are all the same challenge instance.

% Now, suppose the user had a 3-digit secret (KEY,VAL):
%   (1,2), (3,3), (2,1)
% , which would correspond to: (green , square, small).
% Using the first challenge instance {(1,3,1), (2,2,3), (3,1,2)},
% The user would respond with the following grid elements:
%  (2,2,3) , (2,2,3), (3,1,2)


% Mutable parameters
grid_size = 3;
attr_key_cnt = 3;


MIN_KEY_SIZE = 7;
MIN_GRID_SIZE = 2;

MAX_KEY_SIZE = 7;
MAX_GRID_SIZE = 3;


for attr_key_cnt = MIN_KEY_SIZE : MAX_KEY_SIZE
    for grid_size = MIN_GRID_SIZE : MAX_GRID_SIZE

        % Immutable
        attr_val_cnt = grid_size;
        final = [];
        selected = [];
        remaining = repmat(1:attr_val_cnt, attr_key_cnt, 1);
        display(remaining);
        %remaining = [1 2 3 4; 1 2 3 4; 1 2 3 4; 1 2 3 4;]

        % For the first iteration, we fix the initial digit to the first possible
        % attribute key-value. This results in duplicate (reordered) challenge 
        % instances (see above)

        tmp = num2cell(remaining, 2);
        combs = allcomb(tmp{:});
        if 1==1
            for i = 1:size(combs,1)
                new_remaining = [];
                if combs(i,1) ~= remaining(1,1)
                    continue
                end
                % remove the attributes selected for this digit
                % from remaining for the next digit (recurse)
               new_remaining = zeros(size(remaining, 1), size(remaining, 2)-1);
               for j = 1:size(combs, 2) %1:length(combs(i,:))
                new_remaining(j, :) = remaining(j,remaining(j,:) ~= combs(i,j));
               end   
               % add selection (comb elements) to the new selected matrix
               new_selected = combs(i,:);

               %display(new_remaining)
               final = recurse(new_remaining, new_selected, final);
            end
        end

        % final now contains a matrix of challenge instances
        % where each row represents a grid element,
        % whose column indexes the attribute key and the row-column element
        % contains the value under that key. Every GRID_SIZE rows is a challenge 
        % instance.
        %
        %Ex.  1 2 3
        %     2 1 1
        %     3 3 2
        %     1 3 2
        %     2 1 1
        %     3 2 3
        % would express two challenges: 
        % {{(1,2,3),(2,1,1),(3,3,2)},
        %  {(1,3,2),(2,1,1),(3,2,3)}}

        %final_size = size(final,1)/grid_size;
        %display(final);
        %display(final_size);

        %sanity check
        sanity = 1;
        for i = attr_val_cnt:-1:1
            sanity = sanity * (i^attr_key_cnt);
        end
        sanity = sanity / attr_val_cnt;
        if sanity == final_size
            disp('Sanity passed!');
        else
            disp('Insanity passed!');
            display(sanity);
        end
        filename = strcat(num2str(attr_key_cnt), '_', num2str(attr_val_cnt), '.mat');
        save(filename,'final','-mat');
    end
end








function output = recurse(remaining, selected, final)
     if isempty(remaining(1,:))
        %display(selected)
        output = [final; selected];
        return
    end
    tmp = num2cell(remaining, 2);
    combs = allcomb(tmp{:});
    for i = 1:size(combs,1)
       new_remaining = zeros(size(remaining, 1), size(remaining, 2)-1);
       for j = 1:size(combs, 2)
        new_remaining(j, :) = remaining(j,remaining(j,:) ~= combs(i,j));
       end   
       % add comb elements to the new selected matrix
       new_selected = [selected ; combs(i,:)];
       final = recurse(new_remaining, new_selected, final);
    end
    output = final;
end









function A = allcomb(varargin)

% ALLCOMB - All combinations
%    B = ALLCOMB(A1,A2,A3,...,AN) returns all combinations of the elements
%    in the arrays A1, A2, ..., and AN. B is P-by-N matrix is which P is the product
%    of the number of elements of the N inputs. This functionality is also
%    known as the Cartesian Product. The arguments can be numerical and/or
%    characters, or they can be cell arrays.
%
%    Examples:
%       allcomb([1 3 5],[-3 8],[0 1]) % numerical input:
%       % -> [ 1  -3   0
%       %      1  -3   1
%       %      1   8   0
%       %        ...
%       %      5  -3   1
%       %      5   8   1 ] ; % a 12-by-3 array
%
%       allcomb('abc','XY') % character arrays
%       % -> [ aX ; aY ; bX ; bY ; cX ; cY] % a 6-by-2 character array
%
%       allcomb('xy',[65 66]) % a combination
%       % -> ['xA' ; 'xB' ; 'yA' ; 'yB'] % a 4-by-2 character array
%
%       allcomb({'hello','Bye'},{'Joe', 10:12},{99999 []}) % all cell arrays
%       % -> {  'hello'  'Joe'        [99999]
%       %       'hello'  'Joe'             []
%       %       'hello'  [1x3 double] [99999]
%       %       'hello'  [1x3 double]      []
%       %       'Bye'    'Joe'        [99999]
%       %       'Bye'    'Joe'             []
%       %       'Bye'    [1x3 double] [99999]
%       %       'Bye'    [1x3 double]      [] } ; % a 8-by-3 cell array
%
%    ALLCOMB(..., 'matlab') causes the first column to change fastest which
%    is consistent with matlab indexing. Example: 
%      allcomb(1:2,3:4,5:6,'matlab') 
%      % -> [ 1 3 5 ; 1 4 5 ; 1 3 6 ; ... ; 2 4 6 ]
%
%    If one of the arguments is empty, ALLCOMB returns a 0-by-N empty array.
%    
%    See also NCHOOSEK, PERMS, NDGRID
%         and NCHOOSE, COMBN, KTHCOMBN (Matlab Central FEX)

% Tested in Matlab R2015a
% version 4.1 (feb 2016)
% (c) Jos van der Geest
% email: samelinoa@gmail.com

% History
% 1.1 (feb 2006), removed minor bug when entering empty cell arrays;
%     added option to let the first input run fastest (suggestion by JD)
% 1.2 (jan 2010), using ii as an index on the left-hand for the multiple
%     output by NDGRID. Thanks to Jan Simon, for showing this little trick
% 2.0 (dec 2010). Bruno Luong convinced me that an empty input should
% return an empty output.
% 2.1 (feb 2011). A cell as input argument caused the check on the last
%      argument (specifying the order) to crash.
% 2.2 (jan 2012). removed a superfluous line of code (ischar(..))
% 3.0 (may 2012) removed check for doubles so character arrays are accepted
% 4.0 (feb 2014) added support for cell arrays
% 4.1 (feb 2016) fixed error for cell array input with last argument being
%     'matlab'. Thanks to Richard for pointing this out.

    narginchk(1,Inf) ;

    NC = nargin ;

    % check if we should flip the order
    if ischar(varargin{end}) && (strcmpi(varargin{end},'matlab') || strcmpi(varargin{end},'john'))
        % based on a suggestion by JD on the FEX
        NC = NC-1 ;
        ii = 1:NC ; % now first argument will change fastest
    else
        % default: enter arguments backwards, so last one (AN) is changing fastest
        ii = NC:-1:1 ;
    end

    args = varargin(1:NC) ;
    % check for empty inputs
    if any(cellfun('isempty',args))
        warning('ALLCOMB:EmptyInput','One of more empty inputs result in an empty output.') ;
        A = zeros(0,NC) ;
    elseif NC > 1
        isCellInput = cellfun(@iscell,args) ;
        if any(isCellInput)
            if ~all(isCellInput)
                error('ALLCOMB:InvalidCellInput', ...
                    'For cell input, all arguments should be cell arrays.') ;
            end
            % for cell input, we use to indices to get all combinations
            ix = cellfun(@(c) 1:numel(c), args,'un',0) ;

            % flip using ii if last column is changing fastest
            [ix{ii}] = ndgrid(ix{ii}) ;

            A = cell(numel(ix{1}),NC) ; % pre-allocate the output
            for k=1:NC
                % combine
                A(:,k) = reshape(args{k}(ix{k}),[],1) ;
            end
        else
            % non-cell input, assuming all numerical values or strings
            % flip using ii if last column is changing fastest
            [A{ii}] = ndgrid(args{ii}) ;
            % concatenate
            A = reshape(cat(NC+1,A{:}),[],NC) ;
        end
    elseif NC==1
        A = args{1}(:) ; % nothing to combine

    else % NC==0, there was only the 'matlab' flag argument
        A = zeros(0,0) ; % nothing
    end
end
